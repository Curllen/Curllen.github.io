<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybatis系列(五):mybatis延迟加载]]></title>
    <url>%2F2018%2F10%2F31%2Fmybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[联级查询时, 很多情况下只需要单张表的数据, 无需查询所有表, 延时加载实现了这个需求, 减少资源的浪费. 使用说明MyBatis的延迟加载 只能对关联对象进行查询时，使用延迟加载策略。对于主加载对象，均采用直接加载。关联对象以属性的方式添加在主对象中 例如:查询订单表中某个订单信息以及和该订单相关的用户信息: 12graph LR主加载对象:订单对象--&gt;可按需查询的关联对象:用户对象 要应用延迟加载查询，只能使用多表单独查询，而不能使用多表连接查询。因为多表连接查询的本质是查询一张表，将多张表首先连接为了一张表后，再进行的查询。查询一个信息，就会将所有信息全部查询到。 根据前文例子构造用于==非延时加载的传统联合查询的SQL语句==如下: 1select * from order o left join user u on o.user_id=u.id where o.order_number=201810313239 本语句使用了多表连接查询&gt;左连接查询, 延时加载相关设置对其是无效的, 本语句查询结果是一张组合的表, 不可拆解. 改造上文SQL语句,成为适用延时加载SQL语句: 1) mybatis-config.xml开启全局配置 2) 添加cglib的依赖(从3.4.1版本开始不用添加) 3) 添加resultMap和改造原映射文件中SQL语句 相关的pojo: 1234567891011public class Order implements Serializable &#123; private static final long serialVersionUID = 1540810318910L; //订单id private Integer id; //用户id private Long userId; //订单号 private String orderNumber; //用户 private User user; ...set/get等省略... 12345678910111213141516171819public class User &#123; private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; ...set/get等省略... mybatis-config.xml配置12345678&lt;!-- 全局配置参数 --&gt; &lt;settings&gt; &lt;!-- 延迟加载总开关 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt; &lt;!-- 设置按需加载 --&gt; &lt;!-- mybatis在3.4.1开始默认为false--&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt; &lt;/settings&gt; pom.xml添加依赖(假定是maven过程)123456&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 修改映射文件(本例不把resultMap抽取为额外映射文件)123456789101112131415161718192021222324252627282930 &lt;resultMap id=&quot;orderUserLazyMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt; &lt;-- column:查询结果的id字段 property:order对象的id属性 数据库表的主键id映射id, 即使相同也不要省,提高性能 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;!-- property:order对象的user属性 javaType：属性名对应的java类型autoMapping:不写select:指定延迟加载要执行的statement的id（是根据user_id查询用户信息 的statement,注意:需要前边加namespacecolumn：订单表中关联用户表的列，是user_id,作为参数传入statement中, 只有一个参数时statement中的#&#123;&#125;原则上可以随意. 如果是多个参数,则需要使用数组,形如:column=&quot;&#123;a=user_id,aa=参数2,cc=参数3&#125;&quot;, 使用时在statement中的需要哪个参数,如第二个,通过#&#123;aa&#125;/$&#123;aa&#125;来使用 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; select=&quot;selectUserById&quot; column=&quot;user_id&quot;/&gt; &lt;/resultMap&gt; &lt;!-- 语句1,查询订单信息 --&gt; &lt;select id=&quot;selectOrderUserLazy&quot; resultMap=&quot;orderUserLazyMap&quot;&gt; select * from tb_order where order_number = #&#123;orderNumber&#125; &lt;/select&gt; &lt;!-- 语句2,查询用户信息 --&gt; &lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt; select * from tb_user where id = #&#123;id&#125;; &lt;/select&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[mybatis系列(四):maybatis强大特性之resultMap]]></title>
    <url>%2F2018%2F10%2F31%2Fmybatis%E4%B9%8BresultMap%2F</url>
    <content type="text"><![CDATA[位于sql语句所在的映射文件中(也可以抽取为一个单独的映射文件),mybatis最强大的功能, 多用于多表查询的情景 解决两大问题 POJO属性名和表结构字段名不一致的问题(有些情况下也不是驼峰格式) 完成高级查询,包括但是不限于: 一对一、一对多、多对多. 在映射文件中定义 123456789101112&lt;!-- resultMap:自定义映射关系 属性：type-结果集的封装类型，id-唯一标识，autoMapping-开启自动匹配，如果开启了驼峰匹配，就以驼峰匹配的形式进行匹配 id:指定主键映射的，不要省。提高性能 result：其他的非主键普通字段 子标签的属性：Column-表中的字段名，property-对应的java属性名 --&gt; &lt;resultMap type=&quot;User&quot; id=&quot;userMap&quot; autoMapping=&quot;true&quot;&gt; &lt;!-- 数据库表的主键uid映射id, 即使相同也不要省,提高性能 --&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt; &lt;!-- 数据库表的普通字段user_name映射userName --&gt; &lt;result column=&quot;user_name&quot; property=&quot;userName&quot;/&gt; &lt;/resultMap&gt; 自定义resultMap中，主键需要通过id子标签配置，表字段和属性名不一致的普通字段需要通过result子标签配置。那么，字段名称匹配的字段要不要配置那？这个取决于resultMap中的autoMapping属性的值：为true时：resultMap中的没有配置的字段会自动对应。为false时：只针对resultMap中已经配置的字段作映射。并且resultMap会自动映射单表查询的结果集（结果是个集合，自定义resultMap,其type=”实体类”, 集合里存储的是pojo, 故一般而言，任何的select语句都可以使用map存储）。 在映射文件中的使用 在select等标签中,通过rsultMap=”自定义的resultMap的id名”来使用 resulttMap其他参数解析 所有参数 12345678910111213&lt;resultMap&gt; &lt;constructor&gt; &lt;idArg/&gt; &lt;arg/&gt; &lt;/constructor&gt; &lt;id/&gt; &lt;result/&gt; &lt;association/&gt; &lt;collection/&gt; &lt;discriminator &gt; &lt;case/&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; constructor元素 用于配置构造方法。一个pojo可能不存在没有参数的构造方法，则使用constructor进行配置。假设RoleBean不存在没有参数的构造方法，它的构造方法声明为public Role(Integer id,String roleName) 123456&lt;resultMap ...&gt; &lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt; &lt;arg column=&quot;role_name&quot; javaType=&quot;string&quot;/&gt; &lt;/constructor&gt;&lt;/resultMap&gt; mybatis中级联(高级查询)分为这么三种：association，collection和discriminator association：代表一对一关系,作用: 将关联查询信息映射到一个pojo类中 collection：代表一对多关系,作用: 将关联查询信息映射到一个list集合中 discriminator：鉴别器，它可以根据实际选择采用哪个类作为实例，允许根据特定的条件去关联不同的结果集。比如，人有男人和女人，可以实例化一个对象，但是根据情况用男人类或者女人类去实例化 association实体类 12345678910111213public class Order implements Serializable &#123; private Integer id; private Long userId; private String orderNumber; //关联用户信息 private User user; //订单明细 private List&lt;Orderdetail&gt; orderdetails; ...省略get/set方法... SQL语句所在映射文件1234567891011121314151617181920&lt;resultMap type=&quot;Order&quot; id=&quot;orderUserMap&quot; autoMapping=&quot;true&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- association:一对一的映射 property：java的属性名 javaType：属性名对应的java类型 autoMapping:开启自动映射 子标签：参照resultMap --&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; autoMapping=&quot;true&quot;&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- resultType不能完成user信息的映射，必须使用resultMap，resultMap的值对应resultMap标签的id，resultMap和resultType必须二选一 --&gt; &lt;select id=&quot;queryOrderWithUser&quot; resultMap=&quot;orderUserMap&quot;&gt; select * from tb_order a LEFT JOIN tb_user b on a.user_id=b.id where a.order_number = #&#123;number&#125; &lt;/select&gt; collection(例1把resultMap抽取为一个单独的映射文件) 例1:实体类1234567891011121314151617public class Orders implements Serializable &#123; private Integer id; private Integer userId; private String number; private Date createtime; private String note; //关联用户信息 private User user; //订单明细 private List&lt;Orderdetail&gt; orderdetails; ...省略get/set方法... 抽取出来的单独映射文件 123456789101112131415161718&lt;!-- 一对多，查询订单及订单明细 --&gt; &lt;resultMap type=&quot;orders&quot; id=&quot;orderAndOrderDetails&quot; extends=&quot;ordersUserResultMap&quot;&gt; &lt;!-- 映射订单信息，和用户信息，这里使用继承ordersUserResultMap --&gt; &lt;!-- 映射订单明细信息 property：要将关联信息映射到orders的哪个属性中 ofType：集合中pojo的类型 --&gt; &lt;collection property=&quot;orderdetails&quot; ofType=&quot;cn.itcast.mybatis.po.Orderdetail&quot;&gt; &lt;!-- id：关联信息订单明细的唯 一标识 property：Orderdetail的属性名 --&gt; &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt; &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 例2 实体类 12345678910111213public class Order implements Serializable &#123; private Integer id; private Long userId; private String orderNumber; //关联用户信息 private User user; //订单明细 private List&lt;Orderdetail&gt; orderdetails; ...省略get/set方法... SQL语句所在映射文件123456789101112131415161718192021222324&lt;resultMap type=&quot;Order&quot; id=&quot;orderUserDetailMap&quot; autoMapping=&quot;true&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; autoMapping=&quot;true&quot;&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt; &lt;/association&gt; &lt;!-- collection:一对多的查询 property:属性名 javaType：集合类型(可以省略?) ofType：集合中的元素类型 autoMapping：开启自动映射 子标签：参照resultMap --&gt; &lt;collection property=&quot;detailList&quot; javaType=&quot;list&quot; ofType=&quot;Orderdetail&quot; autoMapping=&quot;true&quot;&gt; &lt;id column=&quot;detail_id&quot; property=&quot;id&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;queryOrderWithUserDetail&quot; resultMap=&quot;orderUserDetailMap&quot;&gt; select *,c.id as detail_id from tb_order a LEFT JOIN tb_user b on a.user_id=b.id LEFT JOIN tb_orderdetail c on a.id=c.order_id where a.order_number=#&#123;number&#125; &lt;/select&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>mybatis系列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>mybatis</tag>
        <tag>resultMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis系列(三):抽取SQL片段-优化SQL]]></title>
    <url>%2F2018%2F10%2F31%2Fmybatis%E6%8A%BD%E5%8F%96SQL%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[如果某些sql片段在多个sql语句中被复用,可以将这些sql片段抽取为一个单独的映射文件(例如SQL语句中*,都尽可能用具体的字段名代替,以提高执行效率,这个过程中会出现大量重复sql片段). 抽取片段12345678910111213141516171819&lt;!-- 为何要抽取以下片段,去除SQL语句中的*,可以提高执行效率 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace(命名空间)：映射文件的唯一标识 --&gt;&lt;mapper namespace=&quot;CommonSQL&quot;&gt; &lt;!-- 通过sql标签&gt;id唯一标识片段 --&gt; &lt;sql id=&quot;commonSql&quot;&gt; id,user_name, password, name, age, sex, birthday, created, updated &lt;/sql&gt;&lt;/mapper&gt; 引用片段 mybatis-config.xml 123&lt;mappers&gt; &lt;mapper resource=&quot;CommonSQL.xml&quot;&lt;/mappers&gt; 需要使用片段的映射文件:在需要使用该sql片段的地方通过include标签的refid属性引用该sql片段： 1234567891011121314&lt;!-- &lt;sql id=&quot;commonSql&quot;&gt; id,user_name, password, name, age, sex, birthday, created, updated&lt;/sql&gt; --&gt;&lt;select id=&quot;queryUsersLikeUserName&quot; resultType=&quot;User&quot;&gt; select &lt;include refid=&quot;CommonSQL.commonSql&quot;&gt;&lt;/include&gt; from tb_user where user_name like &apos;%&apos; #&#123;userName&#125; &apos;%&apos;&lt;/select&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>mybatis系列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>mybatis</tag>
        <tag>SQL片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis系列(二):mybatis动态SQL]]></title>
    <url>%2F2018%2F10%2F31%2Fmybatis%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[位于映射文件中,提供OGNL表达式动态生成SQL的功能. 动态SQL if 判断语句, 例如判断是否输入用户名来拼接语句 1234567891011&lt;select id=&quot;queryUserListLikeUserName&quot; resultType=&quot;User&quot;&gt; select * from tb_user where sex=1 &lt;!-- if:判断 test：OGNL表达式 userName:接口文件中通过@param设定的参数名(下同) trim:字符串处理方法,去掉字符串起始和结尾的空格(JQuery也有相同方法) --&gt; &lt;if test=&quot;userName!=null and userName.trim()!=&apos;&apos;&quot;&gt; and user_name like &apos;%&apos; #&#123;userName&#125; &apos;%&apos; &lt;/if&gt;&lt;/select&gt; choose&gt;when,otherwise(&gt;,表示标签级别,&gt;前面是父标签) 条件选择,例如是否输入用户名/年龄来拼接语句(选其一,只选择第一个符合条件(或都不符合情况下的otherwise)的语句进行拼接) 123456789101112&lt;select id=&quot;queryUserListLikeUserNameOrAge&quot; resultType=&quot;User&quot;&gt; select * from tb_user where sex=1 &lt;!-- choose:条件选择 when：test-判断条件，一旦有一个when成立，后续的when都不再执行 otherwise：所有的when都不成立时，才会执行 --&gt; &lt;choose&gt; &lt;when test=&quot;userName!=null and userName.trim()!=&apos;&apos;&quot;&gt;and user_name like &apos;%&apos; #&#123;userName&#125; &apos;%&apos;&lt;/when&gt; &lt;when test=&quot;age != null&quot;&gt;and age = #&#123;age&#125;&lt;/when&gt; &lt;otherwise&gt;and user_name = &apos;zhangsan&apos; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; where 条件选择,和if/choose配合使用,给sql拼接多个语句, 例如即输入了用户名也输入了年龄,全部拼接进SQL语句 123456789101112&lt;select id=&quot;queryUserListLikeUserNameAndAge&quot; resultType=&quot;User&quot;&gt; select * from tb_user &lt;!-- 会在SQL语句中自动添加where关键字 有一定的纠错功能：去掉sql语句块之前多余的一个and|or 通常结合if或者choose使用 --&gt; &lt;where&gt; &lt;if test=&quot;userName!=null and userName.trim()!=&apos;&apos;&quot;&gt;user_name like &apos;%&apos; #&#123;userName&#125; &apos;%&apos;&lt;/if&gt; &lt;if test=&quot;age!=null&quot;&gt;and age = #&#123;age&#125;&lt;/if&gt; &lt;/where&gt; &lt;/select&gt; set 更新信息,和if配合使用,当其中某个if不满足,则数据库不更新该字段,例如更新用户信息,sex=null 123456789101112131415161718&lt;update id=&quot;updateUserSelective&quot; &gt; UPDATE tb_user &lt;!-- 会在SQL语句中自动添加set关键字 也有一定的纠错功能：自动去掉sql语句块之后多余的一个逗号 有关sex的if不通过,则数据库不更新sex的值 --&gt; &lt;set&gt; &lt;if test=&quot;userName!=null and userName.trim()!=&apos;&apos;&quot;&gt;user_name = #&#123;userName&#125;,&lt;/if&gt; &lt;if test=&quot;password!=null and password.trim()!=&apos;&apos;&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;name!=null and name.trim()!=&apos;&apos;&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test=&quot;age!=null&quot;&gt;age = #&#123;age&#125;,&lt;/if&gt; &lt;if test=&quot;sex!=null&quot;&gt;sex = #&#123;sex&#125;,&lt;/if&gt; updated = now(), &lt;/set&gt; WHERE (id = #&#123;id&#125;); &lt;/update&gt; foreach 当参数是集合/数组(集合底层是可变数组),进行遍历(突破参数只能是基本数据类型,HashMap,pojo) 1234567891011121314&lt;select id=&quot;queryUserListByIds&quot; resultType=&quot;User&quot;&gt; select * from tb_user where id in &lt;!-- foreach:遍历集合 collection：接收的集合参数,接口文件中通过@param设定的参数名 item：被遍历的集合中的一个元素 separator:分隔符 open:以什么开始(本例中,如果foreach已经被了&apos;()&apos;包围,则不用open和close close：以什么结束 --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>mybatis系列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>mybatis</tag>
        <tag>动态SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis系列(一):mybatis动态代理]]></title>
    <url>%2F2018%2F10%2F31%2Fmybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[映射文件的配置参数中:parameterType参数都可以不写 默认规则 dao接口名称通常命名为XxxMapper. 映射文件:Xxxmapper.xml, statementid与接口的方法名保持一致.mybatis-config.xml配置(以下按该顺序写) 导入jdbc配置文件(使用$): &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; 开启驼峰匹配：经典的数据库列名（多个单词下划线连接）映射到经典的java属性名(多个单词驼峰连接) &lt;settings&gt;&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 在映射文件中的参数使用别名(就可不用全路径,但开启了也可以全路径),方式2种,只写一种 &lt;typeAliases&gt;//自动将类名转换为别名,大小写不敏感&lt;package name=&quot;包名&quot;&gt;&lt;/typeAliases&gt; environments,可以配置多个environment(环境),选中环境的方式 ①&lt;environments default=&quot;环境id名&quot;&gt;...&lt;environments&gt; ②SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader,&quot;环境id名&quot;); 映入映射文件4种,只写一种&lt;mappers&gt;&lt;mapper resource=&quot;映射文件名&quot;&gt;&lt;/mappers&gt; 映射文件Xxxmapper.xml 将id回写到user对象 useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; 接收参数方式(两种) ①${}:非预编译,直接拼接,不能防止sql注入,通常用于表名,注意,如果sql语句中只用了一个参数,且接口文件没有使用@param注解,则只能固定使用${value}获取参数的值; ②#{}:预编译,只是表示占位，与参数的名字无关，如果只有一个参数，可以使用#{任意参数名}接收参数值，会自动对应 获取多个参数 ${}:接口使用@param注解 #{}:默认规则{0,1,param1,param2},即可以#{0} #{1},或者#{param1} #{param2}; 使用#param注解 如果在接口文件中使用了@param注释,则如果参数是pojo或者HashMap,则需要#{参数名.属性名}/${参数名.属性名} ${}/#{}在使用过程中空格对其的影响, 例如当其为like等的一部分参数,需要在%前后加空格,如’%’ ${} ‘%’,==什么时候加空格?==&gt;&gt;当${}/#{}和其他符号组合成为某个关键字的一个参数时,需要加.(课上说的就是%,具体待验证)]]></content>
      <categories>
        <category>Java</category>
        <category>mybatis系列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>mybatis</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA打包类为Jar]]></title>
    <url>%2F2018%2F10%2F16%2FIDEA%E6%89%93%E5%8C%85%E7%B1%BB%E4%B8%BAJar%2F</url>
    <content type="text"><![CDATA[有的时候需要把自己写工具打包成jar包,供自己或者他人使用. 情况分为两类: 1.自己的工具类没有导入(引用)第三方jar包; 2.自己的工具类引用了第三方jar包. 第一类的处理 对于情况1的处理步骤(以下情况适应一次打包多个文件): 如图, 例如打包实体类中的Book.java 打开File -&gt; Project Structure -&gt; Artifacts -&gt; + -&gt; JAR -&gt; Empty 在Output Layout中,依次建立文件夹,文件夹名字和结构和Book.java所在的路径保持一致 在Output Layout中,点击 + -&gt;file, 添加Book.Class文件 点击 Apply ,再点击 Create Manifest创建配置文MANIFEST.MF,该文件可以定为工程中任意目录下,完成配置 回到IDEA，选择Build -&gt; Build Artifacts，成功生成Jar包。生成的Jar包位于上图设置的Output directory 第二类的处理 对于情况2的处理,可以使用方式1,但是在其他项目中导入自己的jar包后, 也得把自己jar包所依赖的第三方jar包也导入该工程,否者无效,方式1中网上的通过Class-Path设置第三方jar包位置是不可用的,第二种方式如下: 如图, 例如打包实体类中的BeanCommonUtils.java,该类依赖第三方jar包commons-beanutils-1.9.3.jar 打开File -&gt; Project Structure -&gt; Artifacts -&gt; + -&gt; JAR -&gt; From modules with dependencies 上图出现的相关参数说明如下: module是你需要打成jar包的项目 MainClass是运行的主函数，如果不需要运行则可以不选择 jar files from libraries是项目打包的方式，下面选项大致的含义： extract to the target jar：把所有文件倒入进一个jar包里 copy to the。。。。：把项目的依赖包导出和项目一个目录，通过MANIFEST.MF文件来引用jar包。 回到IDEA，选择Build -&gt; Build Artifacts，成功生成Jar包。生成的Jar包位于上图设置的Output directory 这里如果你的项目需要打成一个可运行的jar包推荐第二种，反之第一种。另,未验证:如果项目中引用的Jar包有签名过，最后打包成的Jar包运行时会抛出错误：java.lang.SecurityException: Invalid signature file digest for Manifest main attributes From modules with dependencies，==会把在项目中用到的Jar包解压开==，当成项目的一部分，打包到最后的Jar包中，这样就不会出现采用方式1时，通过网上说的使用Class-Path方式设置第三方jar包位置时导致出现的找不到类异常。 ==该方式只适合于该工程所有类都需要被打包到该jar包中的情况!== ==生成的jar中会有该工程lib文件夹下的第三方jar包, 这些jar已不产生作用, 可以删除!== ​]]></content>
      <categories>
        <category>IDEA</category>
        <category>JAR</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>打包</tag>
      </tags>
  </entry>
</search>
